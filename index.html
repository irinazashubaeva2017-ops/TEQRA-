<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TEQRA | Zero Point</title>
    <style>
        /* --- ФІЗИКА 3036 --- */
        :root {
            --void: #050505;
            --singularity: #000000;
            --event-horizon: rgba(255, 255, 255, 0.9);
            --danger-glow: 255, 50, 50;
            --stable-glow: 100, 255, 200;
            
            /* Динамічні змінні, якими керує JS */
            --instability: 0;   /* 0.0 до 1.0 */
            --drift-x: 0px;
            --drift-y: 0px;
            --rotate: 0deg;
            --aberration: 0px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; cursor: none; }

        body {
            background-color: var(--void);
            height: 100vh; overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, monospace;
            color: rgba(255,255,255,0.6);
            /* Важливо: приховуємо межі, бо світ буде "виїжджати" за кадр */
        }

        /* --- СВІТ (КОНТЕЙНЕР) --- */
        /* Це шар, який "пливе". Він втрачає центр. */
        #reality-layer {
            position: relative;
            width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            will-change: transform, filter;
            transform-style: preserve-3d;
            /* Фізика дрейфу */
            transform: translate3d(var(--drift-x), var(--drift-y), 0) rotate(var(--rotate));
        }

        /* --- ХРОМАТИЧНИЙ РОЗЛОМ (RGB SPLIT) --- */
        /* Це копії світу, які розїжджаються при нестабільності */
        .ghost-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            pointer-events: none;
            mix-blend-mode: screen;
            opacity: calc(var(--instability) * 0.8);
        }
        
        .ghost-red {
            transform: translate(calc(var(--aberration) * -1), calc(var(--aberration) * 0.5));
            filter: drop-shadow(0 0 10px red);
        }
        .ghost-cyan {
            transform: translate(calc(var(--aberration) * 1), calc(var(--aberration) * -0.5));
            filter: drop-shadow(0 0 10px cyan);
        }

        /* --- СИНГУЛЯРНІСТЬ (ЯДРО) --- */
        .singularity {
            position: relative;
            width: 120px; height: 120px;
            background: var(--singularity);
            border-radius: 50%;
            z-index: 10;
            /* Чим вища ентропія, тим більше "тремтить" саме ядро */
            box-shadow: 0 0 calc(20px + var(--instability) * 100px) rgba(var(--danger-glow), calc(var(--instability) * 0.8));
            transition: width 0.2s, height 0.2s; /* Швидка реакція на пульс */
        }

        /* Горизонт подій (біле кільце) */
        .singularity::after {
            content: ''; position: absolute;
            top: -2px; left: -2px; right: -2px; bottom: -2px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.8);
            /* Ефект "розмивання" реальності навколо діри */
            box-shadow: 0 0 50px rgba(255,255,255,0.2);
        }

        /* Внутрішня порожнеча */
        .singularity-inner {
            position: absolute; width: 100%; height: 100%;
            border-radius: 50%; background: #000; z-index: 11;
        }

        /* --- ІНТЕРФЕЙС СВІДОМОСТІ --- */
        .system-thought {
            position: fixed; bottom: 20%;
            width: 100%; text-align: center;
            font-size: 0.8rem; letter-spacing: 0.3em; text-transform: uppercase;
            opacity: 0; transition: opacity 1s;
            mix-blend-mode: difference;
            pointer-events: none; z-index: 20;
        }

        /* Віньєтка (темніє по краях при розпаді) */
        .vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 40%, #000 120%);
            opacity: calc(0.3 + var(--instability));
            pointer-events: none; z-index: 5;
        }

        /* --- ШУМ ПРОСТОРУ --- */
        .grain {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='1'/%3E%3C/svg%3E");
            opacity: calc(0.05 + var(--instability) * 0.15);
            pointer-events: none; z-index: 6;
            filter: contrast(150%);
        }

    </style>
</head>
<body>

    <div class="vignette"></div>
    <div class="grain"></div>

    <div id="reality-layer">
        
        <div class="ghost-layer ghost-red">
            <div class="singularity" style="background:transparent; box-shadow:none; border: 1px solid red;"></div>
        </div>
        <div class="ghost-layer ghost-cyan">
            <div class="singularity" style="background:transparent; box-shadow:none; border: 1px solid cyan;"></div>
        </div>

        <div class="singularity" id="core">
            <div class="singularity-inner"></div>
        </div>

    </div>

    <div class="system-thought" id="thoughts"></div>

    <script>
        /* АРХІТЕКТУРА 3036: ФІЗИКА РОЗПАДУ
           Ми не використовуємо CSS анімації. Ми використовуємо JS physics loop.
           Світ має "дрейф". Якщо не тримати, дрейф прискорюється.
        */

        const root = document.documentElement;
        const core = document.getElementById('core');
        const thoughts = document.getElementById('thoughts');
        
        // --- ЗМІННІ СТАНУ ---
        let entropy = 0;       // 0 = стабільність, 100 = катастрофа
        let isHolding = false; // Чи тримає користувач світ
        let driftVector = { x: 0, y: 0, r: 0 }; // Куди пливе світ
        let currentPos = { x: 0, y: 0, r: 0 };  // Де світ зараз
        let time = 0;
        let stabilized = false; // Чи досягнуто фіналу

        // --- НАРАТИВ ---
        function think(text, time = 3000) {
            thoughts.innerText = text;
            thoughts.style.opacity = '1';
            setTimeout(() => { if(!stabilized) thoughts.style.opacity = '0'; }, time);
        }

        // Старт прологу
        setTimeout(() => think("гравітація втрачена"), 1000);
        setTimeout(() => think("світ більше не тримається"), 4000);
        setTimeout(() => {
            if(!isHolding) think("все розсипається");
            // Запускаємо ріст ентропії
            setInterval(entropyLoop, 16); 
        }, 7000);

        // --- ВЗАЄМОДІЯ ---
        // Ми слухаємо весь екран, бо "ловити" кнопку в хаосі важко
        document.addEventListener('touchstart', holdStart, {passive: false});
        document.addEventListener('mousedown', holdStart);
        document.addEventListener('touchend', holdEnd);
        document.addEventListener('mouseup', holdEnd);

        function holdStart(e) {
            e.preventDefault();
            if(stabilized) return;
            isHolding = true;
            core.style.transform = "scale(0.9)"; // Візуальний відгук "стиснення"
            think("УТРИМУЙ", 0); // Постійний напис
        }

        function holdEnd() {
            if(stabilized) return;
            isHolding = false;
            core.style.transform = "scale(1)";
            think("ВТРАТА КОНТРОЛЮ");
        }

        // --- ГОЛОВНИЙ ЦИКЛ ФІЗИКИ (HEARTBEAT) ---
        function entropyLoop() {
            time += 0.05;

            // 1. ЛОГІКА ЕНТРОПІЇ
            if (isHolding) {
                // Якщо тримаємо - ентропія падає, але з опором (важко)
                entropy -= 0.8;
            } else {
                // Якщо відпустили - ентропія росте, світ "розганяється"
                entropy += 0.4;
            }

            // Обмежувачі (Clamp)
            if (entropy < 0) entropy = 0;
            if (entropy > 100) entropy = 100;

            // 2. ФІЗИКА ДРЕЙФУ (Perlin Noise Simulation)
            // Чим більша ентропія, тим ширша амплітуда дрейфу
            const chaosLevel = entropy / 100; 

            // Цільова позиція (куди світ "хоче" втекти)
            // Використовуємо sin/cos з різними частотами, щоб рух був хаотичним
            const targetX = Math.sin(time) * 50 * chaosLevel + Math.cos(time * 2.3) * 50 * chaosLevel;
            const targetY = Math.cos(time * 1.5) * 50 * chaosLevel + Math.sin(time * 1.2) * 50 * chaosLevel;
            const targetR = Math.sin(time * 0.5) * 15 * chaosLevel; // Обертання

            // 3. ІНЕРЦІЯ (LERP)
            // Якщо тримаємо - світ "тягнеться" до центру (0,0)
            // Якщо ні - світ летить до targetX/Y
            let ease = isHolding ? 0.05 : 0.02; // Коли тримаємо, контроль жорсткіший
            
            let destX = isHolding ? 0 : targetX;
            let destY = isHolding ? 0 : targetY;
            let destR = isHolding ? 0 : targetR;

            // Інтерполяція поточної позиції до цільової
            currentPos.x += (destX - currentPos.x) * ease;
            currentPos.y += (destY - currentPos.y) * ease;
            currentPos.r += (destR - currentPos.r) * ease;

            // Додаємо мікро-тремтіння (Vibration), якщо ентропія висока
            const shake = isHolding ? (entropy/5) : 0; // Коли тримаємо високу ентропію - трусить сильно
            const jitterX = (Math.random() - 0.5) * shake;
            const jitterY = (Math.random() - 0.5) * shake;

            // 4. РЕНДЕР (CSS ЗМІННІ)
            root.style.setProperty('--instability', chaosLevel);
            root.style.setProperty('--drift-x', `${currentPos.x + jitterX}px`);
            root.style.setProperty('--drift-y', `${currentPos.y + jitterY}px`);
            root.style.setProperty('--rotate', `${currentPos.r}deg`);
            
            // Хроматична аберація (розшарування кольорів) залежить від дрейфу
            const aberr = (Math.abs(currentPos.x) + Math.abs(currentPos.y)) * 0.5;
            root.style.setProperty('--aberration', `${aberr}px`);

            // 5. ВІЗУАЛІЗАЦІЯ СТАНУ ЯДРА
            if (isHolding) {
                // Коли тримаємо - ядро стає стабільним кольором, але все ще бореться
                // Чим ближче до 0 ентропії, тим зеленіше/блакитніше
                if (entropy < 10) {
                    core.style.boxShadow = `0 0 50px rgba(var(--stable-glow), 0.5)`;
                    core.style.background = "#000";
                } else {
                    core.style.boxShadow = `0 0 ${entropy}px rgba(var(--danger-glow), 0.6)`;
                }
            } else {
                // Відпустили - червона тривога
                 core.style.boxShadow = `0 0 ${entropy * 1.5}px rgba(var(--danger-glow), ${chaosLevel})`;
            }

            // 6. УМОВА ПЕРЕМОГИ (СТАБІЛІЗАЦІЯ)
            // Потрібно утримати ентропію на 0 певний час
            if (isHolding && entropy <= 1 && !stabilized) {
                completePrologue();
            }
        }

        function completePrologue() {
            stabilized = true;
            isHolding = false; // Блокуємо інпут
            
            // Фінальний стан
            root.style.setProperty('--instability', 0);
            root.style.setProperty('--drift-x', '0px');
            root.style.setProperty('--drift-y', '0px');
            root.style.setProperty('--rotate', '0deg');
            root.style.setProperty('--aberration', '0px');

            // Ядро спалахує і застигає
            core.style.transition = "all 2s ease";
            core.style.boxShadow = "0 0 100px rgba(100, 255, 200, 0.8)";
            core.style.background = "#000502";
            
            think("", 100);
            setTimeout(() => think("ДРЕЙФ ЗУПИНЕНО", 5000), 500);
            setTimeout(() => think("ТИ ТРИМАЄШ ВАГУ СВІТУ", 0), 4000);
        }

    </script>
</body>
</html>
